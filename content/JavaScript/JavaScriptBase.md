---
title: "JS는 인터프리터일까? 컴파일러일까"
date: 2026-02-01
subtitle: "인터프리터와 컴파일러, 그리고 V8 엔진의 동작"
category: "JavaScript"
tags:
  - javascript
background: "javascript/ComputerScience.jpeg"
emoji: "🖥️"
draft: false
---

결론부터 말하면, **현대 JavaScript는 둘 다이다.**

근데 이 말이 왜 나오는 걸까?

<br/>

## 전통적인 구분부터 이해하자

### 💻 컴파일 언어 (C, C++ 등)

> 코드를 실행 전에 한 번에 번역하는 프로그램 (비유 : 영어 책을 한국어로 전부 번역한 뒤 읽는 것)

```
코드 → 컴파일 → 기계어 → 실행
```

1. 전체 코드를 기계어로 번역한다.
2. 실행 파일(.exe 같은 것) 생성한다.
3. 그 다음에 실행한다.

**특징**

- 실행 전에 전체 코드를 번역한다.
- 실행 속도가 빠르다.
- 실행 전에 에러를 발견할 가능성이 있다.

### 📝 인터프리터 언어 (예전 Python, 옛 JS 인식)

> 코드를 한 줄씩 읽으면서 바로 실행하는 프로그램 (비유 : 영어 책을 한 문장씩 보면서 그때그때 해석하며 읽는 것)

```
코드 → 한 줄씩 읽으며 실행
```

- 실행할 때마다 읽고 해석한다.
- 미리 기계어 파일을 만들지 않고 번역하지 않는다.
- 비교적 느릴 수 있다.

<br/>

**그런데 JS는 이 둘 중 하나가 아니다**

옛날에는 JS를 인터프리터라고 불렀다. 왜냐하면 **“한 줄씩 읽으며 실행한다”** 라고 알려져 있었기 때문이다. 하지만 현대 엔진(V8, SpiderMonkey 등)은 다르게 동작한다.

<br/>

## 실제 JS 엔진 동작 흐름 (V8 기준 단순화)

```
1. 전체 코드 Parsing (파싱) & AST 생성
2. 필요한 부분만 Bytecode 생성
4. 실행
5. 자주 호출되는 부분은 JIT 최적화
```

### 1. Parsing

```js
const a = 10;
```

엔진은 이걸 바로 실행하지 않고 먼저 전체 코드를 읽고 문법 분석해서 문법 구조로 바꾼다. (전체 스크립트 단위로 진행된다.) → **`AST (Abstract Syntax Tree)`**

즉, 코드 구조를 트리로 만드는 거라고 보면된다.

### 2. Bytecode로 변환 (컴파일)

`AST`는 바로 실행되지 않고 엔진은 `AST`를 `Bytecode`(중간 코드)로 변환하는데 이 과정이 이미 “**컴파일**”이다.

**👉 여기서 JS는 이미 인터프리터가 아니라는걸 확인할 수 있다.**

여기서 중요한 부분은 엔진은 성능과 초기 로딩 속도 때문에 지금 당장 실행 안 할 함수는 깊게 컴파일하지 않는다. 그래서 이 과정에서는 필요한 부분만 Bytecode로 생성한다.

### 3. 실행

이 `Bytecode`를 인터프리터가 실행한다.

### 4. JIT (Just-In-Time) 최적화

JS는 어떤 함수가 자주 실행되면, 엔진은 그 부분을 기계어로 다시 컴파일해서 최적화 시키는데 이걸 **JIT**라고 한다. 즉, 처음엔 가볍게 실행하다가 자주 쓰이면 고성능 코드로 업그레이드를 시킨다.

<br/>

## 그래서 결론은?

**JS는:**

- 미리 전체를 기계어로 컴파일하지도 않는다.
- 한 줄씩 단순 해석하지도 않는다.
- 실행 중 최적화까지 한다.

**JS 엔진은:**

- 일단 돌아가게 만든다.
- 자주 쓰이면 최적화한다.
- 그래서 JS는 생각보다 빠르다
- 전략: Adaptive Optimization (처음엔 가볍게, 많이 쓰이면 빠르게 전략을 가지고 있다.)

👉 **인터프리터 + 컴파일러 + JIT 최적화 엔진 = JavaScript**

<br/>

## 더 깊게 파고들기

### 1. JS는 왜 실행 전에 에러를 전부 잡지 못할까?

- JS는 정적 타입 언어가 아니다.
  - JS는 실행 전에 **타입을 확정할 수 없기때문에** `let a =10` 에서 **`a`가 숫자인지, 문자열인지, 객체인지 확정할 수 없다.**
- 변수 존재 여부는 실행 시점에 결정된다
  - 함수 안에서 변수가 존재하는지는 호출될 때 또는 해당 스코프 체인을 탐색할 때 결정되기에 파싱 단계에서는 잡지 못한다.
- Lazy Compilation
  - 당장 실행 안 되는 함수 내부까지 깊게 최적화하지 않고 문법만 다 검사한다..

### 2. 타입이 동적인데 어떻게 최적화가 가능할까?

```js
function multiply(x, y) {
  return x * y;
}
```

위의 함수를 엔진이 "관찰"하다가 같은 함수를 1000번 실행했는데 `x` 와`y` 가 전부 숫자 였다면 엔진은 내부적으로 함수를 숫자 전용이라고 생각한다. 그래서 숫자 전용 머신 코드로 최적화한다.

하지만 만약, 갑자기 `multiply("a",3)` 코드가 들어오면, 엔진은 타입이 바뀜을 인지하고 최적화 코드를 버리고 다시 일반 코드로 돌아간다. 이걸 **de-optimization**이라고 한다.

<br/>
